{"meta":{"title":"江南品味|记录编程道路上的点点滴滴!!!","subtitle":"记录编程道路上的点点滴滴!!!","description":"记录编程道路上的点点滴滴!!!","author":"江南品味","url":"http://blog.jiangnan.pw"},"pages":[{"title":"所有归档","date":"2016-12-22T01:40:13.820Z","updated":"2016-11-14T15:39:25.000Z","comments":false,"path":"all-archives/index.html","permalink":"http://blog.jiangnan.pw/all-archives/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"关于作者","date":"2017-01-06T07:51:03.085Z","updated":"2017-01-06T07:51:03.085Z","comments":false,"path":"about/index.html","permalink":"http://blog.jiangnan.pw/about/index.html","excerpt":"","text":"本博客基于Hexo创建，主要记录在工作学习的过程中遇到的一些问题以及解决方法。","raw":null,"content":null},{"title":"所有栏目","date":"2016-12-22T01:40:13.820Z","updated":"2016-11-14T15:39:39.000Z","comments":false,"path":"all-categories/index.html","permalink":"http://blog.jiangnan.pw/all-categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"所有标签","date":"2016-12-22T01:40:13.820Z","updated":"2016-11-14T15:39:56.000Z","comments":false,"path":"all-tags/index.html","permalink":"http://blog.jiangnan.pw/all-tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"解决升级 OS X EI Capitan 后 Wineskin 打包的游戏无法运行的问题","slug":"解决升级-OS-X-EI-Capitan-后-Wineskin-打包的游戏无法运行的问题","date":"2017-01-20T04:05:05.000Z","updated":"2017-01-20T07:39:39.454Z","comments":true,"path":"2017/01/20/解决升级-OS-X-EI-Capitan-后-Wineskin-打包的游戏无法运行的问题/","link":"","permalink":"http://blog.jiangnan.pw/2017/01/20/解决升级-OS-X-EI-Capitan-后-Wineskin-打包的游戏无法运行的问题/","excerpt":"","text":"此前苹果发布了 OS X 的新版本 EI Capitan，系统有更新当然是立马进行升级享受新鲜事物带来的快感了，但前几天想玩耍一局 Pro Evolution Soccer(实况足球)的时候，发现我深爱的游戏再也启动不起来了，和同样爱玩儿实况的同事交流之后发现情况大致有如下两种： 双击 .app 文件，程序是可以打开的，但是窗口始终无法显示（我的电脑）； 双击 .app 文件，程序无法打开，系统提示 X11 无法打开，截图如下（同事的）： 无法在绿茵场上尽情驰骋，这种事显然不能忍，立马去 Wineskin 官网看了看，发现有一条关于 OS X EI Capitan 的新闻： Wineskin does not currently work correctly on El Capitan. The issue is being looked into, but I have no ETA for a fix. I’ll get a fix out as soon as I can.Some people have been able to upgrade to the latest version of XQuartz, and change their wrappers to use XQuartz and not WineskinX11 and have gotten wrappers to work, but this method has not worked for everyone.Please add to the discussion here if you are helping find a solution. 又看到有一条新版本发布的新闻： I’ve released an update for Wineskin… version 2.6.1.I think I’ve fixed all the El Capitan bugs and it should work fine on 10.6 - 10.11 now.important point. This has to change how an engine is installed in a wrapper slightly. If you update a wrapper to 2.6.1 and it does not work right, please reinstall the engine in the wrapper. You can just use Change Engine and install the same one back in, but it will install it correctly for 2.6.1 and then things should work right. Newly made wrappers should have no issues. 这说明官方发布的最新的 2.6.1 版本已经解决了该问题，那么剩下的问题就简单多了，我们只需要将 Wineskin Wrapper 给替换成官方发布的最新版本即可。 解决办法 在应用程序中找到需要修复的游戏，右键选择 显示包内容； 打开 Wineskin.app，选择 advance，记录下引擎版本号： 下载最新版本的 Wineskin Winery； 打开 Wineskin Winery，添加一个新的 engine，版本号最好与之前记录的版本号一致： 更新 Wrapper Version 至最新版，只要在 2.6.1 以上即代表已经使用了官方修复 OS X EI Capitan 问题的 Wrapper： 选择 Create New Blank Wrapper，填写游戏名称并选择 Create。如果有提示需要安装东西，都可以选择 Cancel； 创建成功后，将原游戏 .app 文件包内容中的 Content/Resources/driver_c 文件夹以及 Content/Resources/system.reg、Content/Resources/user.reg、Content/Resources/userdef.reg 这三个文件覆盖到我们新创建的 Wrapper 文件包内容中的 Content/Resources/ 文件夹中，它们分别相当于 Windows 系统中的 C 盘和注册表； 再打开我们新创建的 Wrapper 文件包内容中的 &#39;Wineskin.app&#39;，选择 advance，然后选择程序的启动路径，即刚刚覆盖的 driver_c 文件夹中我们想要启动的 exe 程序： 退回到我们在第 6 步中生成新 Wineskin Wrapper 的目录，当然现在它已经是一个完整的游戏程序了，双击运行它，然后 enjoy it! 鉴于评论区有朋友反映下载 engine 和 wrapper 总是失败，所以现在将最新的 engine 和 wrapper 上传到网盘供大家下载： Engine 1.7.52 下载地址，提取码：ikhq； Wrapper 2.6.1 下载地址，提取码：v1dh。 下载后，将 WS9Wine1.7.52.tar.7z 这个文件放入 ~/Library/Application Support/Wineskin/Engines 这个文件夹；将 Wineskin-2.6.1.app.zip 这个文件解压缩，得到 Wineskin-2.6.1.app 这个文件，将其放入 ~/Library/Application Support/Wineskin/Wrapper 这个文件夹，然后重新打开上面第 3 步中下载的 Wineskin Winery，如果 engine 和 wrapper 都已经存在了，直接进行第 6 步的操作即可。 再放上 Wineskin Winery 的网盘地址： Wineskin Winery 1.7 下载地址，提取码：dpdu。","raw":null,"content":null,"categories":[{"name":"Mac","slug":"Mac","permalink":"http://blog.jiangnan.pw/categories/Mac/"},{"name":"Mac技巧","slug":"Mac/Mac技巧","permalink":"http://blog.jiangnan.pw/categories/Mac/Mac技巧/"}],"tags":[{"name":"Mac技巧","slug":"Mac技巧","permalink":"http://blog.jiangnan.pw/tags/Mac技巧/"}]},{"title":"Nginxのエラーページをカスタマイズする方法","slug":"Nginxのエラーページをカスタマイズする方法","date":"2017-01-19T08:06:00.000Z","updated":"2017-01-20T06:24:06.350Z","comments":true,"path":"2017/01/19/Nginxのエラーページをカスタマイズする方法/","link":"","permalink":"http://blog.jiangnan.pw/2017/01/19/Nginxのエラーページをカスタマイズする方法/","excerpt":"","text":"Nginxのデフォルトのエラーページは格好良くないし、Nginxを使ってることがバレバレです。それが嫌だったので以下の方法でカスタマイズしました。 基本 Nginxではエラーページのカスタマイズにはerror_pageディレクティブを使います。カスタマイズの基本的な方法は、custom_404.htmlを作って、nginxの設定ファイルを以下の様な感じにします。これで、Nginxを再起動して、存在しないファイルへリクエストするとcustom_404.htmlが帰ってくるようになります。 123456789101112server &#123; # 中略 error_page 404 /custom_404.html; location = /custom_404.html &#123; root /opt/nginx/html; internal; &#125; # 中略&#125; 応用 以下では、よりより実践的な例を紹介します。 IP直打ちでのアクセスは全てエラーページを表示 IPアドレスを直接入力してアクセスしてきた場合や想定外のホスト名でアクセスしてきた場合に常にcustom_404.htmlを表示したければ以下の様にします。 1234567891011server &#123; listen 80 default_server; error_page 404 /custom_404.html; location / &#123; return 404; &#125; location = /custom_404.html &#123; root /opt/nginx/html; internal; &#125;&#125; どんなエラーが発生しても404ページを返す 実際に発生しているエラーが403だろうが503だろうが、ユーザーには404エラーが発生しているように見せかけます。下の例では400, 401, 403, 500, 502, 503のいずれが発生してもクライアントに返すHTTPステータスコードを404に書き換え、custom_404.htmlを返します。 123456789server &#123; listen 80; server_name example.com; error_page 400 401 403 404 500 502 503 =404 /custom_404.html; location = /custom_404.html &#123; root /opt/nginx/html; internal; &#125;&#125; 管理画面を隠す 特定のIP以外から管理画面へアクセスされた時は404画面を出します。この例では192.168.0.1からの管理画面へのリクエストは許可し、それ以外の場合は404ステータスとcustom_404.htmlを返します。","raw":null,"content":null,"categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/categories/技术分享/"},{"name":"Nginx","slug":"技术分享/Nginx","permalink":"http://blog.jiangnan.pw/categories/技术分享/Nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://blog.jiangnan.pw/tags/nginx/"}]},{"title":"江南云服务正式上线","slug":"江南云服务正式上线","date":"2017-01-10T05:10:27.000Z","updated":"2017-01-20T05:49:50.307Z","comments":true,"path":"2017/01/10/江南云服务正式上线/","link":"","permalink":"http://blog.jiangnan.pw/2017/01/10/江南云服务正式上线/","excerpt":"","text":"江南云-提供基于百度云，天翼云(正在开发中Y(^_^)Y)的云存储服务，包括图片，音乐，视频，文件的云存储下载服务。 提供百度云，天翼云本身不支持的迅雷等工具直接下载的功能。 采用用户本地存储TOKEN的方式进行授权，充分保证用户的个人隐私 提供图片，音视频等流媒体的直接外链功能，从此站长再也不用费心找图床。","raw":null,"content":null,"categories":[{"name":"作品展示","slug":"作品展示","permalink":"http://blog.jiangnan.pw/categories/作品展示/"}],"tags":[{"name":"江南云","slug":"江南云","permalink":"http://blog.jiangnan.pw/tags/江南云/"},{"name":"作品展示","slug":"作品展示","permalink":"http://blog.jiangnan.pw/tags/作品展示/"}]},{"title":"Laravel5自定义环境变量","slug":"Laravel 5 自定义环境变量","date":"2016-12-01T07:19:55.000Z","updated":"2017-02-03T04:46:47.528Z","comments":true,"path":"2016/12/01/Laravel 5 自定义环境变量/","link":"","permalink":"http://blog.jiangnan.pw/2016/12/01/Laravel 5 自定义环境变量/","excerpt":"","text":"Laravel 5 中提供了一种通过.env文件定义环境变量的方式，根据官方文档的说明应该在不同的环境下使用不同的.env文件，并且此文件不应该提交到版本控制中去。如此设定自然是为了方便不同的环境或者多名开发人员完全可以使用自已的.env环境变量。 但是官方文档中对于如何自定义.env文件中的环境变量却提的很少。文档中只提及了在需要自定义环境变量时最好是在.env.example文件中写一份变量的定义，以方便其他开发人员配置。 下面就以我的“遭遇”来讲下 Laravel 5 中如何自定义环境变量。 （内容比较啰嗦，可直接跳到最后环境变量的正确用法部分） 问题因为我需要路由里面根据不同的二级域名选择不同的控制器，而测试环境和生产环境中的顶级域名不同，于是我打算把顶级域名作为一项环境变量写在.env文件中。 123.envAPP_BASE_URL=test.com 路由中的写法（为了演示我把路由的处理直接写成了闭包，而实际用于生产环境的代码是不能写成闭包的，原因就是路由缓存不支持闭包，不打算使用路由缓存的可以无视）： 12345678route.php$_app_base_url = env('APP_BASE_URL');Route::group(['domain' =&gt; \"u.&#123;$_app_base_url&#125;\"], function() &#123; Route::get('/', function()&#123; return \"TEST\"; &#125;);&#125;); 恶梦就此开始。 env()函数与$_ENV超全局变量这种写法本身是没有任何问题的，访问u.test.com，在开发环境中一切正常。然后使用命令php artisan config:cache生成配置缓存后却出现了找不到控制器的错误。经过调试发现$_app_base_url的输出值是null。 env()函数的作用是从$_ENV超全局变量中取出对应的值，而 Laravel 在启动的时候又会自动加载.env文件中的信息到$_ENV超全局变量中，所以如果没问题的话在$_ENV环境变量中应该能找到刚才定义的环境变量。 1var_dump($_ENV); 输出了很多环境变量的信息，但。。。没有看到任何在.env里面定义的信息。难道信息没有被加载到$_ENV？于是尝试清除配置缓存：php artisan config:clear后再尝试，发现.env里面的信息确实被加载到了$_ENV超全局变量中。。。 看来这个问题和配置缓存脱不了关系了。 配置缓存Laravel 中为了加快程序的执行效率做了很多缓存优化的工作，其中就包括配置缓存、路由缓存等，通过把多个零碎的配置文件合并成一个大的配置文件来减少加载的文件数量，从而加快运行速度（如果你研究过PHP的性能的话就会知道IO操作其实占了很大一部分开销）。 Laravel 的配置缓存被保存在bootstrap/cache/config.php文件中。打开这个文件可以看到这个文件就是把config文件夹的所有文件合并成了一个大的配置文件。config.php直接返回一个数组，数组的键名对应config文件夹下的文件名，数组的值对应config文件夹下文件返回的配置信息。 找遍整个配置文件发现没有任何和.env文件里面的定义相关的内容。 难道env()函数会从配置缓存中读取数据，因为这个文件里面没有对应的数据所以才返回null？抱着这个想法去查看env()的源码，发现这个函数和配置缓存没任何关系。。。 .env文件的加载这时我产生一个想法：有没有可能是框架检测存在配置缓存文件时就不去加载.env了呢？ 如果是这样的话框架源码里面肯定会有地方去判断bootstrap/cache/config.php文件是否存在。 直接在vendor里面搜cache/config.php，果然找到在vendor/laravel/framework/src/Illuminate/Foundation/Application.php的第836行（关于文件和行的信息都是基本我现在使用的 Laravel 5.2.31，版本号不同具体位置也可能不同）： 1234567891011Application.php/** * Get the path to the configuration cache file. * * @return string */public function getCachedConfigPath()&#123; return $this-&gt;bootstrapPath().&apos;/cache/config.php&apos;;&#125; getCachedConfigPath()函数返回了这个配置缓存文件的路径。继续查找这个函数，发现除了控制台部分外共有两个地方使用了这个函数，分别是Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::LoadConfiguration和Illuminate\\Foundation\\Application::configurationIsCached。前者是判断如果配置缓存文件存在就包含它，并不再从config文件夹下加载配置文件；后者是定义了一个configurationIsCached()函数用于返回配置缓存文件是否存在。 根据线索继续查找configurationIsCached()函数，找到了唯一的调用方：vendor/laravel/framework/src/Illuminate/Foundation/Bootstrap/DetectEnvironment.php的第19行： 123456789101112131415161718192021222324DetectEnvironment.phpclass DetectEnvironment&#123; /** * Bootstrap the given application. * * @param \\Illuminate\\Contracts\\Foundation\\Application $app * @return void */ public function bootstrap(Application $app) &#123; if (! $app-&gt;configurationIsCached()) &#123; $this-&gt;checkForSpecificEnvironmentFile($app); try &#123; (new Dotenv($app-&gt;environmentPath(), $app-&gt;environmentFile()))-&gt;load(); &#125; catch (InvalidPathException $e) &#123; // &#125; &#125; &#125; // ......&#125; 在bootstrap()中可以看到，这里会检查配置缓存文件是否存在，如果不存在就会去加载.env文件，否则就什么都不做。正好验证了前面的猜测：在生成配置缓存之后就不会去加载.env文件了。 （通过上面代码中的$this-&gt;checkForSpecificEnvironmentFile($app);往下跟踪，发现还可以使用.env.APP_ENV的方式定义跟随环境的配置信息，例如.env中如果定义了APP_ENV=local的话，在加载环境变量时也会尝试加载.env.local文件）。 .env应该什么时候被加载？至此应该是真相大白了。那么.env应该什么时候被加载呢？ 当然开发环境中不需要生成配置缓存，所以每次请求都会重新加载和解析.env文件并设置到$_ENV超全局变量中。生产环境中呢？ 这时另一个猜想产生了：既然bootstrap/cache/config.php缓存文件中没有关于环境变量的信息，并且系统没有尝试加载.env文件，会不会有可能是已经把环境变量保存到了config.php缓存文件中了呢？如果真的是这样的话，那么env()函数就只能在config/*.php中的配置文件里面被调用（因为生成了配置缓存后就不再加载环境变量，程序的其它地方再去访问环境变量是得不到.env里面的信息的）。 全局搜索env(，猜对了，果然只在config文件夹里面的文件中使用这个函数，其它地方是没有调用过的。 综合整理一下上面的过程，也就是说如果在.env里面自定义了一个环境变量，就需要在config文件夹下的任意一个配置文件中把这个环境变量添加进去，这样生成的配置缓存中才会包含这个信息。 环境变量的正确用法好吧，只能说明是我认为是正确的用法。 首先肯定是要在自己的.env文件中定义这个环境变量： 123.envAPP_BASE_URL=test.com 然后还需要把这个环境变量的定义写到.env.example文件中，以方便团队协作时其他成员能更好的理解你定义的这个变量。 然后很重要的一步，你还需要把这个环境变量写到配置文件中去。因为生成配置缓存时加载配置文件的过程是遍历整个config文件夹，所以你可以在config文件中任意新建一个PHP文件用来保存自己定义的环境变量，或者修改现有的任一配置文件。 就以新建配置文件为例吧，在config文件夹下新建demo.php文件： 123456demo.php&lt;?phpreturn [ &apos;app_base_url&apos; =&gt; env(&apos;APP_BASE_URL&apos;, &apos;default value&apos;),]; 是的，我们是在这个配置文件中调用的env()函数。这样在生成配置缓存时就会在这里读取环境变量。 命令行执行； 1php artisan config:cache 然后再打开bootstrap/cache/config.php文件，会发现其中多了一部分: 123456config.php//.......&apos;demo&apos; =&gt; array( &apos;app_base_url&apos; =&gt; &apos;test.com&apos;, ), 至此自定义环境变量的过程已经圆满结束。当然因为使用了配置缓存，所以在程序中需要读取自定义环境变量的时候也就不能使用env()函数。内容存储在配置中，自然要用config()函数。 上面的例子： 12345678route.php$_app_base_url = config(&apos;demo.app_base_url&apos;);Route::group([&apos;domain&apos; =&gt; &quot;u.&#123;$_app_base_url&#125;&quot;], function() &#123; Route::get(&apos;/&apos;, function()&#123; return &quot;TEST&quot;; &#125;);&#125;); config()函数使用点号作为分隔符，点号前面部分是配置文件名（例子中配置文件是demo.php，所以是demo），点号后面是配置项的键名（app_base_url）。 总结总结就是如果你想同时使用自定义环境变量和配置缓存的话，你就需要自定义一个配置项来读取环境变量的值。 最后记得不要忘了把创建配置缓存命令写到你的构建脚本或自动部署中。","raw":null,"content":null,"categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/categories/技术分享/"},{"name":"Laravel","slug":"技术分享/Laravel","permalink":"http://blog.jiangnan.pw/categories/技术分享/Laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://blog.jiangnan.pw/tags/laravel/"}]},{"title":"Laravel5导入自定义函数和类的方法","slug":"Laravel5导入自定义函数和类的方法","date":"2016-12-01T07:19:55.000Z","updated":"2017-01-19T08:20:11.285Z","comments":true,"path":"2016/12/01/Laravel5导入自定义函数和类的方法/","link":"","permalink":"http://blog.jiangnan.pw/2016/12/01/Laravel5导入自定义函数和类的方法/","excerpt":"","text":"我们的应用里经常会有一些全局都可能会用的函数，我们应该怎么放置它会比较好呢？以下有一种推荐的方式： 导入自定义函数我们的应用里经常会有一些全局都可能会用的函数，我们应该怎么放置它会比较好呢？以下有一种推荐的方式： 创建文件 app/helpers.php 123456&lt;?php// 示例函数function foo() &#123; return &quot;foo&quot;;&#125; 修改项目 composer.json 在项目 composer.json 中 autoload 部分里的 files 字段加入该文件即可： 12345678910&#123; ... &quot;autoload&quot;: &#123; &quot;files&quot;: [ &quot;app/helpers.php&quot; ] &#125; ...&#125; 然后运行:1composer dump-autoload OK，然后你就可以在任何地方用到 app/helpers.php 中的函数了。 导入自定义类比如说我要加载一个名字是BaiduPCS.php类文件 修改项目 composer.json 在项目 composer.json 中 autoload 部分里的 classmap 字段加入该文件所在的文件夹即可： 12345678910111213&quot;autoload&quot;: &#123; &quot;classmap&quot;: [ &quot;database&quot;, &quot;app/DDL/Classes&quot; &lt;== 就是这里 ], &quot;files&quot;: [ &quot;app/DDL/Functions/functions.php&quot; ], &quot;psr-4&quot;: &#123; &quot;App\\\\&quot;: &quot;app/&quot;, &quot;DDL\\\\&quot;:&quot;app/DDL/&quot; &#125;&#125;, 然后运行:1composer dump-autoload OK，然后你就可以在你要使用该类的地方添加以下代码来使用。 1use BaiduPCS;","raw":null,"content":null,"categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/categories/技术分享/"},{"name":"Laravel","slug":"技术分享/Laravel","permalink":"http://blog.jiangnan.pw/categories/技术分享/Laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://blog.jiangnan.pw/tags/laravel/"}]},{"title":"常用图床及自建图床方法汇总","slug":"常用图床及自建图床方法汇总","date":"2016-11-10T06:28:41.000Z","updated":"2017-01-19T08:21:36.733Z","comments":true,"path":"2016/11/10/常用图床及自建图床方法汇总/","link":"","permalink":"http://blog.jiangnan.pw/2016/11/10/常用图床及自建图床方法汇总/","excerpt":"","text":"国内图床的中流砥柱，速度非常快，服务也较为稳定，目前还支持了 HTTPS ，同时有大量的第三方工具…… 公共图床微博图床国内图床的中流砥柱，速度非常快，服务也较为稳定，目前还支持了 HTTPS ，同时有大量的第三方工具方便使用，缺点是批量上传比较麻烦。 官方上传地址 新浪微博图床 Chrome 插件 围脖图床 Chrome 插件（网页版不可用，Firefox 版在附加组件中搜索安装即可） imgur09年就成立了的国外老牌图床，支持https，理论上不限制大小，还有邮件发图、视频转 GIF 、URL 上传等功能，很强大，可惜间歇性被墙，就算没被墙国内访问也很慢，面向国外的站点使用倒很合适。 地址：https://imgur.com sm.ms支持https，有 API ，图片要求大小在 5MB 以下，一次上传不得超过10张，维护者是 通天塔 的站长。主站 https://sm.ms 目前用的是阿里云新加坡的机器，而上传的图片则会被存储到使用阿里云香港的 https://ooo.0o0.ooo 中，因此速度还是很不错的。 地址：https://sm.ms API：https://sm.ms/doc/ otar.im这个网站本身并不是一个图床，但却做到了一个更比三个强，整合上文提到的微博图床、imgur、sm.ms 到一个页面中，非常方便实用。然而最近使用时提示未知错误上传失败，不知是否停止维护了。 地址：http://upload.otar.im/ V2EX 图片库程序员社区 v2ex 推出的付费图床服务，由于博主没有需求所以未付费使用过，效果不明。 地址：https://www.v2ex.com/i/about LightPic使用其自己开发的系统，站点规则中写明了不保证图片可以永久存储，似乎使用了 CloudFlare 非中国版的 CDN ，因此支持 https ，但是 CF 在国内部分地区的访问效果很堪忧。 地址：https://lightpic.info picwindow国外图床，号称长久而稳定的储存，图片要求大小在 10MB 以下，国内访问速度一般但可以接受，缺点是上传时有些慢，且不支持 HTTPS ，不过他的远程上传（其实也就是通过 URL 直接上床图片）的功能还是很好用的。 地址：http://www.picwindow.com/ 贴图库早年的神级图床，可惜后来因为某种原因关停，恢复后暂时使用了 kekaoyun 这个域名，现在已经切换回了原域名，但是也从关停前的永久免费变为了6个月免费，也就是免费存储的图片只保存六个月，并提供了付费的商业选项。速度没得说，但是不适合博客这样的站点使用。 地址：http://www.tietuku.com/ 费用详情：http://www.tietuku.com/open 萝莉图床也是早年一个很好用的图床，但是现在需要邀请注册才能使用。 地址：http://loli.io/ 自建图床七牛、又拍云等云存储这些服务商其实是做 CDN 和云存储的，但是由于有一定的免费存储及流量额度，所以也有很多人拿来做自己博客的图床，速度可以和微博图床媲美，各种以其为基础开发的第三方工具用起来也很顺手，缺点是大部分都不支持 https ，同时注册时要求上传身份证信息挺麻烦的。下面推荐几个具有代表性的服务商及第三方工具： 服务商： 七牛：http://www.qiniu.com/ 又拍云：https://www.upyun.com/index.html 工具： iPic (Mac only)：http://i.toolinbox.net/iPic/iPicUploader.html yotuku：http://yotuku.cn/ PHP版七牛图床：https://github.com/4679/qiniu-picbed Get Link：https://github.com/int64ago/getlink 树洞外链 树洞外链是一款免费开源的PHP外链网盘系统，界面简洁友好，支持七牛、本地、远程、阿里云OSS、又拍云五种储存方式，支持多用户系统，多上传方案策略。 官方给出了这样的说明，实际使用下来也确实不错，有文档、安装方便也比较稳定，但存在着一些小 Bug ，小站点用来自建图床还是很合适的。 官网：https://yun.aoaoao.me/ Github：https://github.com/HFO4/shudong-share Lychee一款开源的图片管理系统，实际上也可以用作图床，一直在更新，自身功能很强大，还支持二次开发插件及扩展来丰富功能，此外这套系统也支持 Docker 。 GIthub：https://github.com/electerious/Lychee","raw":null,"content":null,"categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/categories/技术分享/"}],"tags":[{"name":"开源","slug":"开源","permalink":"http://blog.jiangnan.pw/tags/开源/"},{"name":"图床","slug":"图床","permalink":"http://blog.jiangnan.pw/tags/图床/"}]},{"title":"MacOSX10.11开启任意显示器HiDPI方法","slug":"MacOSX10-11开启任意显示器HiDPI方法","date":"2016-11-08T05:27:16.000Z","updated":"2017-01-06T12:47:13.410Z","comments":true,"path":"2016/11/08/MacOSX10-11开启任意显示器HiDPI方法/","link":"","permalink":"http://blog.jiangnan.pw/2016/11/08/MacOSX10-11开启任意显示器HiDPI方法/","excerpt":"","text":"MacOSX10.11开启任意显示器HiDPI方法 研究了下，其实没怎么变化。Overrides文件夹目录位置变了而已。本人开启HiDPI现在更主要是为了截图截出2x的效果，实际调整分辨率的是另一个小显示器~已经很久用不到HiDPI的真实意义啦 对于权限问题的补充10.11系统权限设置又改动，一些系统文件只有“系统”有权限读写，首先要关闭这个权限：开机按住 command ＋ R，进入恢复模式，然后在“终端”中输入“csrutil disable”关闭权限。如果需要打开，则csrutil enable。这是在知乎上看到相同的问题，别人提到的。LZ好像没遇到过这种情况，如果有人遇到同样的权限问题，这样解决就好了。 对于权限问题的补充 开启HiDPI打开终端 键入sudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES回车后，输入当前系统管理员的密码，继续回车确认。 获取你的显示器的两个 ID:DisplayVendorID和DisplayProductID打开终端, 命令分别是: 12ioreg -l | grep &quot;DisplayVendorID&quot;ioreg -l | grep &quot;DisplayProductID&quot; OK.在桌面上新建一个文件夹,名字格式是:DisplayVendorID-XXXX,其中XXXX是你的DisplayVendorID的16进制值小写.于是,我会新建一个 DisplayVendorID-XXXX的文件夹,然后在这个文件夹里面新建一个空白文件.名字格式是DisplayProductID-YYYY,自然YYYY就是你的DisplayProductID的16进制了.我新建的文件是 DisplayProductID-YYYY.最好下载我提供的模板编辑.相信你不一定能找到个合适的进制转换工具，我从网上找到了一个很好用的flash，并把它放到了自己的服务器里，大家如有需要随时可以去用在线进制转换器建议使用PlistPro工具编辑，方便快捷。.范例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;DisplayProductID&lt;/key&gt; &lt;integer&gt;10496&lt;/integer&gt; &lt;key&gt;DisplayVendorID&lt;/key&gt; &lt;integer&gt;8547&lt;/integer&gt; &lt;key&gt;scale-resolutions&lt;/key&gt; &lt;array&gt; &lt;data&gt; AAAKAAAABkAAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAUAAAADIAAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAKAAAABDgAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAUAAAACHAAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAHgAAABDgAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAPAAAACHAAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAGkAAABBoAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAANIAAACDQAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAGQAAAA4QAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAMgAAABwgAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAFoAAAA4QAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAALQAAABwgAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAINAAAA4QAAAABACAAAA== &lt;/data&gt; &lt;data&gt; AAAQaAAABwgAAAABACAAAA== &lt;/data&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 建议下载本帖子中的附件。包含本范例。 最后面那一坨,和以及里面的data如何来的比如我想使用1600900这个HiDPI,那么我就需要生成两个分辨率,其中一个是1600900,一个是其双倍,3200*1800.1600,900两个值的16进制是00000640 00000384 ;3200,1800两个值的16进制是00000C80 00000708;后面加上 00000001 00200000于是会得到1200000640 00000384 00000001 0020000000000C80 00000708 00000001 00200000 用附件中的PlistPro编辑这个DisplayProductID-YYYY,计算并填写你想要的分辨率.最后,把这个 DisplayVendorID-XXXX 文件夹, 拷贝到1/System/Library/Displays/Contents/Resources/Overrides/ (10.10及以下是 /System/Library/Displays/Overrides/ )重启系统就可以看到了.可以安装RDM切换,在任务栏,方便快捷.各位可以根据自己的屏幕规格来添加. 范例中，设定的分辨率是2560x1600 2x (16:10)2560x1080 2x (21:9)1920x1080 2x (16:9)1680x1050 2x (16:10)1600x900 2x(16:9)1440x900 2x(16:10)2100x900 2x(21:9)","raw":null,"content":null,"categories":[{"name":"Mac","slug":"Mac","permalink":"http://blog.jiangnan.pw/categories/Mac/"},{"name":"Mac技巧","slug":"Mac/Mac技巧","permalink":"http://blog.jiangnan.pw/categories/Mac/Mac技巧/"}],"tags":[{"name":"Mac技巧","slug":"Mac技巧","permalink":"http://blog.jiangnan.pw/tags/Mac技巧/"}]},{"title":"禁止WordPress头部加载s.w.org","slug":"禁止WordPress头部加载s-w-org","date":"2016-10-17T05:49:24.000Z","updated":"2017-01-19T08:14:09.817Z","comments":true,"path":"2016/10/17/禁止WordPress头部加载s-w-org/","link":"","permalink":"http://blog.jiangnan.pw/2016/10/17/禁止WordPress头部加载s-w-org/","excerpt":"","text":"WordPress在头部添加dns-prefetch，应该是为了从s.w.org预获取表情和头像，目的是提高网页加载速度 ，但s.w.org国内根本无法访问，什么预获取、什么提高速度，都是泡影，不仅没用处，反而可能会影响速度，那就禁止它。 升级到WordPress 4.6之后，有童鞋发现头部加载了一个:1&lt;link rel=&apos;dns-prefetch&apos; href=&apos;//s.w.org&apos;&gt; WordPress在头部添加dns-prefetch，应该是为了从s.w.org预获取表情和头像，目的是提高网页加载速度 ，但s.w.org国内根本无法访问，什么预获取、什么提高速度，都是泡影，不仅没用处，反而可能会影响速度，那就禁止它。 将下面的代码添加到主题functions.php模板中：方法一1remove_action( &apos;wp_head&apos;, &apos;wp_resource_hints&apos;, 2 ); 方法二1234567function remove_dns_prefetch( $hints, $relation_type ) &#123;if ( &apos;dns-prefetch&apos; === $relation_type ) &#123;return array_diff( wp_dependencies_unique_hosts(), $hints );&#125;return $hints;&#125;add_filter( &apos;wp_resource_hints&apos;, &apos;remove_dns_prefetch&apos;, 10, 2 ); 方法二貌似兼容性更好些。附带一个禁止加载表情代码1234// Remove emoji scriptremove_action( &apos;wp_head&apos;, &apos;print_emoji_detection_script&apos;, 7 );remove_action( &apos;wp_print_styles&apos;, &apos;print_emoji_styles&apos; );add_filter( &apos;emoji_svg_url&apos;, &apos;__return_false&apos; ); 参考：https://wordpress.org/support/topic/remove-the-new-dns-prefetch-code/","raw":null,"content":null,"categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/categories/技术分享/"},{"name":"WordPress","slug":"技术分享/WordPress","permalink":"http://blog.jiangnan.pw/categories/技术分享/WordPress/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://blog.jiangnan.pw/tags/WordPress/"},{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/tags/技术分享/"}]},{"title":"WordPress 后台文件管理插件：FileBrowser","slug":"WordPress-后台文件管理插件：FileBrowser","date":"2016-10-17T05:05:54.000Z","updated":"2017-01-19T08:14:57.061Z","comments":true,"path":"2016/10/17/WordPress-后台文件管理插件：FileBrowser/","link":"","permalink":"http://blog.jiangnan.pw/2016/10/17/WordPress-后台文件管理插件：FileBrowser/","excerpt":"","text":"WordPress 后台文件管理插件：FileBrowser WordPress 后台文件管理插件：FileBrowser wordpress本身没有像dedecms那样的在线文件管理功能，一般的文件管理都得通过FTP来实现，把文件下载下来，然后再编辑上传，很麻烦，而且有的空间根本不支持FTP，所以我们可以使用wordpress后台文件管理插件：FileBrowser。 原版下载地址汉化版下载地址","raw":null,"content":null,"categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/categories/技术分享/"},{"name":"WordPress","slug":"技术分享/WordPress","permalink":"http://blog.jiangnan.pw/categories/技术分享/WordPress/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://blog.jiangnan.pw/tags/WordPress/"},{"name":"plugins","slug":"plugins","permalink":"http://blog.jiangnan.pw/tags/plugins/"}]},{"title":"获取WordPress当前分类文章所有标签","slug":"获取WordPress当前分类文章所有标签","date":"2016-10-17T04:25:16.000Z","updated":"2017-01-19T08:14:30.073Z","comments":true,"path":"2016/10/17/获取WordPress当前分类文章所有标签/","link":"","permalink":"http://blog.jiangnan.pw/2016/10/17/获取WordPress当前分类文章所有标签/","excerpt":"如果需要在分类列表页面，显示当前分类文章中添加的所有标签，方便读者阅读自己喜欢的内容，下面的代码可以帮你实现这个功能。获取WordPress当前分类文章所有标签","text":"如果需要在分类列表页面，显示当前分类文章中添加的所有标签，方便读者阅读自己喜欢的内容，下面的代码可以帮你实现这个功能。获取WordPress当前分类文章所有标签 首先，在主题functions.php模板文件中添加以下函数：12345678910111213141516171819202122232425262728293031function get_category_tags($args) &#123; global $wpdb; $tags = $wpdb-&gt;get_results (&quot; SELECT DISTINCT terms2.term_id as tag_id, terms2.name as tag_name FROM $wpdb-&gt;posts as p1 LEFT JOIN $wpdb-&gt;term_relationships as r1 ON p1.ID = r1.object_ID LEFT JOIN $wpdb-&gt;term_taxonomy as t1 ON r1.term_taxonomy_id = t1.term_taxonomy_id LEFT JOIN $wpdb-&gt;terms as terms1 ON t1.term_id = terms1.term_id, $wpdb-&gt;posts as p2 LEFT JOIN $wpdb-&gt;term_relationships as r2 ON p2.ID = r2.object_ID LEFT JOIN $wpdb-&gt;term_taxonomy as t2 ON r2.term_taxonomy_id = t2.term_taxonomy_id LEFT JOIN $wpdb-&gt;terms as terms2 ON t2.term_id = terms2.term_id WHERE t1.taxonomy = &apos;category&apos; AND p1.post_status = &apos;publish&apos; AND terms1.term_id IN (&quot;.$args[&apos;categories&apos;].&quot;) AND t2.taxonomy = &apos;post_tag&apos; AND p2.post_status = &apos;publish&apos; AND p1.ID = p2.ID ORDER by tag_name &quot;); $count = 0; if($tags) &#123; foreach ($tags as $tag) &#123; $mytag[$count] = get_term_by(&apos;id&apos;, $tag-&gt;tag_id, &apos;post_tag&apos;); $count++; &#125; &#125; else &#123; $mytag = NULL; &#125; return $mytag;&#125; 编译：http://www.ludou.org/wordpress-get-tags-specific-to-category.html源代码出自：https://wordpress.org/support/topic/get-tags-specific-to-category 其次，将下面调用输出代码，添加到主题archive.php模板适当位置： 12345678910111213&lt;?php $cat= single_cat_title(&apos;&apos;, false); $args = array( &apos;categories&apos; =&gt; get_cat_ID($cat)); $tags = get_category_tags($args); $content .= &quot;&lt;ul class=&apos;cat-tag&apos;&gt;&quot;; if(!empty($tags)) &#123; foreach ($tags as $tag) &#123; $content .= &quot;&lt;li&gt;&lt;a href=\\&quot;&quot;.get_tag_link($tag-&gt;term_id).&quot;\\&quot;&gt;&quot;.$tag-&gt;name.&quot;&lt;/a&gt;&lt;/li&gt;&quot;; &#125; &#125; $content .= &quot;&lt;/ul&gt;&quot;; echo $content;?&gt; 个人感觉放到头部调用函数：1&lt;?php get_header(); ?&gt; 下面比较合适。最后，再适当加上样式即可： 12345678.cat-tag&#123; float: left; width: 100%;&#125;.cat-tag li a&#123; float: left; margin: 0 5px;&#125;","raw":null,"content":null,"categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/categories/技术分享/"},{"name":"WordPress","slug":"技术分享/WordPress","permalink":"http://blog.jiangnan.pw/categories/技术分享/WordPress/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://blog.jiangnan.pw/tags/WordPress/"},{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/tags/技术分享/"}]},{"title":"Alfred实现七牛上传文件","slug":"Alfred实现七牛上传文件","date":"2016-10-16T00:48:27.000Z","updated":"2017-01-10T06:58:08.874Z","comments":true,"path":"2016/10/16/Alfred实现七牛上传文件/","link":"","permalink":"http://blog.jiangnan.pw/2016/10/16/Alfred实现七牛上传文件/","excerpt":"","text":"alfred-workflow-qshellqshell 是基于七牛API参考手册实现的一个方便开发者测试和使用七牛API服务的命令行工具。 alfred-workflow-qshell qshell 是基于七牛API参考手册实现的一个方便开发者测试和使用七牛API服务的命令行工具。 alfred-workflow-qshell 是一个配合七牛开发者工具 qshell 使用的 Alfred workflow。 alfred-workflow-qshell 使用可视化流程后台执行 qshell 命令行，易用高效。 功能 &amp; 特点功能 支持多文件上传 支持上传文件添加前缀 获取空间文件外链 查看空间文件基本信息 移动、复制、删除、重命名 预览、下载空间文件 完善的文件操作反馈（通知、错误等） 特点 curl 下载文件 不支持文件夹上传要求空间的文件名为不能为空或全为空格 使用上传文件 默认关键字 fput 搜索本地单个文件，上传文件 搜索文件时使用 Buffer 功能进行文件多选，上传多文件（Buffer 的使用） 选中一或多个文件，调出 Actions 文件操作菜单，上传文件 操作文件 默认关键字 fstat 搜索空间文件 移动、复制、删除、重命名、外链、信息、预览、下载 安装 &amp; 配置要求：qshell、Alfred with Powerpack 1. qshell或前往 GitHub 安装：只需要下载 zip 包之后解压即可使用。Mac 64 位系统只需要解压后的文件 qshell_darwin_amd64。把此文件放到 /usr/local/bin 目录。 配置：从七牛的后台的账号设置中获取 AccessKey 和 SecretKey。配置本地 qshell： 1234# 设置密钥qshell account [AccessKey] [SecretKey]# 查看设置qshell account 注意：上面的设置命令不需要输入方括号 []。 配置 qshell 完毕后会生成 ~/.qshell 文件夹，其中 account.json 文件保存了 AccessKey 和 SecretKey 信息。 2. Alfred下载后缀名为 .alfredworkflow 的安装包安装即可。 注意：Alfred 需要购买 Powerpack 才能解锁 workflows 功能。 Todo [x] account，显示当前用户的 AccessKey 和 SecretKey [x] fput，以文件表单的方式上传一个文件 [x] stat，查询七牛空间中一个文件的基本信息 [x] delete，删除七牛空间中的一个文件 [x] move，移动或重命名七牛空间中的一个文件 [x] copy，复制七牛空间中的一个文件 [x] 查新基本信息时可以获取文件外链 [x] 预览功能 [x] 下载功能","raw":null,"content":null,"categories":[{"name":"Mac","slug":"Mac","permalink":"http://blog.jiangnan.pw/categories/Mac/"},{"name":"Mac技巧","slug":"Mac/Mac技巧","permalink":"http://blog.jiangnan.pw/categories/Mac/Mac技巧/"}],"tags":[{"name":"Alfred","slug":"Alfred","permalink":"http://blog.jiangnan.pw/tags/Alfred/"},{"name":"Mac技巧","slug":"Mac技巧","permalink":"http://blog.jiangnan.pw/tags/Mac技巧/"}]},{"title":"自动从其它站点RSS抓取文章","slug":"自动从其它站点RSS抓取文章","date":"2016-10-13T08:17:14.000Z","updated":"2017-01-19T08:14:38.621Z","comments":true,"path":"2016/10/13/自动从其它站点RSS抓取文章/","link":"","permalink":"http://blog.jiangnan.pw/2016/10/13/自动从其它站点RSS抓取文章/","excerpt":"代码基本原理，新建一个自定义分类法“shot”，自动从另一个站点的RSS抓取文章，放在一个数组中，再用这个数组创建“shot”文章，并为文章添加自定义栏目image和link_url，方便调用缩略图和原文链接。","text":"代码基本原理，新建一个自定义分类法“shot”，自动从另一个站点的RSS抓取文章，放在一个数组中，再用这个数组创建“shot”文章，并为文章添加自定义栏目image和link_url，方便调用缩略图和原文链接。 将下面代码添加到当前主题functions.php中即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?/* Post Type ------------------------------------------------------------------------------------ */add_action( 'init', 'register_cpt_shot' );function register_cpt_shot() &#123; $labels = array( 'name' =&gt; _x( 'Dribble Shots', 'shot' ), 'singular_name' =&gt; _x( 'Dribbble Shot', 'shot' ), 'add_new' =&gt; _x( 'Add New', 'shot' ), 'add_new_item' =&gt; _x( 'Add New Dribbble Shot', 'shot' ), 'edit_item' =&gt; _x( 'Edit Dribbble Shot', 'shot' ), 'new_item' =&gt; _x( 'New Dribbble Shot', 'shot' ), 'view_item' =&gt; _x( 'View Dribbble Shot', 'shot' ), 'search_items' =&gt; _x( 'Search Dribble Shots', 'shot' ), 'not_found' =&gt; _x( 'No dribble shots found', 'shot' ), 'not_found_in_trash' =&gt; _x( 'No dribble shots found in Trash', 'shot' ), 'parent_item_colon' =&gt; _x( 'Parent Dribbble Shot:', 'shot' ), 'menu_name' =&gt; _x( 'Dribble Shots', 'shot' ), ); $args = array( 'labels' =&gt; $labels, 'hierarchical' =&gt; false, 'supports' =&gt; array( 'title', 'custom-fields' ), 'public' =&gt; true, 'show_ui' =&gt; true, 'show_in_menu' =&gt; true, 'show_in_nav_menus' =&gt; false, 'publicly_queryable' =&gt; true, 'exclude_from_search' =&gt; false, 'has_archive' =&gt; true, 'query_var' =&gt; true, 'can_export' =&gt; true, 'rewrite' =&gt; true, 'capability_type' =&gt; 'post' ); register_post_type( 'shot', $args );&#125;/* Import Shots via RSS ------------------------------------------------------------------------------------ */// grab the image src from teh descriptionfunction get_image($string) &#123; preg_match_all('/&lt;img[^&gt;]+&gt;/i',$string, $result); $img = array(); foreach( $result[0] as $img_tag) &#123; preg_match_all('/(src)=(\"[^\"]*\")/i',$img_tag, $img[$img_tag]); &#125; return trim($img[$img_tag][2][0], '\"');&#125;// create an array of the feed itemsinclude_once(ABSPATH . WPINC . '/feed.php');$feed = fetch_feed('http://dribbble.com/tammyhart/shots.rss');$feed = $feed-&gt;get_items(0);$shots = array();foreach ( $feed as $item ) :$shots[$item-&gt;get_date('Ymd')] = array( 'id' =&gt; $item-&gt;get_date('Ymd'), 'url' =&gt; esc_url( $item-&gt;get_permalink() ), 'date' =&gt; $item-&gt;get_date('Y-m-d H:i:s'), 'title' =&gt; esc_html( $item-&gt;get_title() ), 'image' =&gt; get_image($item-&gt;get_description()) );endforeach;// create posts from our arrayforeach ($shots as $shot) &#123; $shot_post = array( 'post_type' =&gt; 'shot', 'post_status' =&gt; 'publish', 'post_author' =&gt; 1, 'post_title' =&gt; $shot['title'], 'post_date' =&gt; $shot['date'] ); $shot_post_meta = array( 'link_url' =&gt; $shot['url'], 'image' =&gt; $shot['image'] ); $posts = get_posts( array( 'post_type' =&gt; 'shot', 'meta_key' =&gt; 'link_url', 'meta_value'=&gt; $shot_post_meta['link_url'] ) ); if (count($posts) == 0) &#123; $post_id = wp_insert_post($shot_post); add_post_meta($post_id, 'link_url', $shot_post_meta['link_url'], true); add_post_meta($post_id, 'image', $shot_post_meta['image'], true); &#125;&#125;?&gt; 修改第66行的”http://dribbble.com/tammyhart/shots.rss“为准备抓取文章站点的RSS地址，还可以修改第80行后的”shot“为你所用主题自定义分类法名称，抓取的文章会自动添加到该分类法中。上述代码中并没有抓取文章内容的功能，仅供参考学习之用。","raw":null,"content":null,"categories":[{"name":"技术分享","slug":"技术分享","permalink":"http://blog.jiangnan.pw/categories/技术分享/"},{"name":"WordPress","slug":"技术分享/WordPress","permalink":"http://blog.jiangnan.pw/categories/技术分享/WordPress/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://blog.jiangnan.pw/tags/WordPress/"}]},{"title":"热烈庆祝江南品味正式上线！","slug":"热烈庆祝江南品味正式上线！","date":"2016-10-13T07:39:35.000Z","updated":"2017-01-19T08:13:36.217Z","comments":true,"path":"2016/10/13/热烈庆祝江南品味正式上线！/","link":"","permalink":"http://blog.jiangnan.pw/2016/10/13/热烈庆祝江南品味正式上线！/","excerpt":"","text":"最近，本地搭建的Web系统遭遇黑客攻击，积累了三年的代码资源都被植入了恶意代码。 背景 最近，本地搭建的Web系统遭遇黑客攻击，积累了三年的代码资源都被植入了恶意代码。经过了两天的努力奋战挽救回来了所有的代码。但是保加利亚的黑客不断的扫描我的IP，致使我的电脑CPU一度达到80℃~90℃，无奈之下展示关闭服务器。 结果 目前转投HEXO，Github门下开始技术博客的更新，今天发布的只是一个测试文章，因为MarkDown的语法还不熟悉只能边学边写希望大家谅解。最后热烈庆祝江南品味正式上线！","raw":null,"content":null,"categories":[{"name":"作品展示","slug":"作品展示","permalink":"http://blog.jiangnan.pw/categories/作品展示/"}],"tags":[{"name":"江南品味","slug":"江南品味","permalink":"http://blog.jiangnan.pw/tags/江南品味/"}]}]}